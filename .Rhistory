# Subset to 7dpi samples
Idents(myel) <- "sample_id"
myel <- subset(myel, idents = c("7dpi_sample1", "7dpi_sample2"))
# Set identity to celltype for downstream subsetting
Idents(myel) <- "celltype"
colnames(myel@meta.data)
ElbowPlot(myel, 50)
# Compute tSNE
myel <- RunTSNE(myel, dims = 1:15, verbose = T)
TSNEPlot(myel, cols =paletteer_c("grDevices::Sunset", 6))
TSNEPlot(myel)
# Cache object locally (NOT tracked by git)
saveRDS(myel, file.path(DIR_LOCAL_CACHE, "milich_B_myeloid_seurat.rds"))
myel$celltype
levels(myel$celltype)
# -----------------------------------------------------------------------------
# 2) Subset macrophages/monocytes and recluster
# -----------------------------------------------------------------------------
# These label names must match your object’s "celltype" levels
macro <- subset(myel, idents = c("Macrophage", "Monocyte"))
macro <- NormalizeData(macro)
macro <- FindVariableFeatures(macro, selection.method = "vst")
# Regress technical covariates
macro <- ScaleData(
macro,
features = rownames(macro),
vars.to.regress = c("nFeature_RNA", "nCount_RNA")
)
macro <- RunPCA(macro, npcs = 50, features = VariableFeatures(macro))
ElbowPlot(macro, ndims = 50)
macro <- FindNeighbors(macro, dims = 1:30, reduction = "pca")
macro <- FindClusters(macro, resolution = 0.31)
macro <- RunTSNE(macro, dims = 1:40, verbose = TRUE)
TSNEPlot(macro)
# Cache macrophage/monocyte object locally
saveRDS(macro, file.path(DIR_LOCAL_CACHE, "milich_B_macro_seurat.rds"))
# -----------------------------------------------------------------------------
# 3) Markers + top10 signatures
# -----------------------------------------------------------------------------
clustmarks <- FindAllMarkers(macro, logfc.threshold = 0.25, min.pct = 0.3, only.pos = TRUE) %>%
filter(p_val_adj < 0.05)
# Write full marker tables per cluster
dir.create(file.path(DIR_TABLES, "milich_B"), showWarnings = FALSE, recursive = TRUE)
for (cl in sort(unique(clustmarks$cluster))) {
tmp <- clustmarks %>%
filter(cluster == cl) %>%
arrange(desc(avg_log2FC))
write.csv(tmp,
file.path(DIR_TABLES, "milich_B", paste0("markers_cluster_", cl, ".csv")),
row.names = FALSE)
}
# Top10 by adj p (avg_log2FC > 1, then first 10 per cluster)
top10 <- clustmarks %>%
group_by(cluster) %>%
filter(avg_log2FC > 1) %>%
slice_head(n = 10) %>%
ungroup()
write.csv(top10, file.path(DIR_TABLES, "top10_milich_macrophage_clusters.csv"), row.names = FALSE)
source("scripts/pipeline/00_config.R")
suppressPackageStartupMessages({
library(tidyverse)
library(Seurat)
})
dataset_id <- "milich_B"
readRDS(file.path(DIR_LOCAL_CACHE, "milich_B_macro_seurat.rds"))
myel <- readRDS(file.path(DIR_LOCAL_CACHE, "milich_B_myeloid_seurat.rds"))
# -----------------------------------------------------------------------------
# 2) Subset macrophages/monocytes and recluster
# -----------------------------------------------------------------------------
# These label names must match your object’s "celltype" levels
macro <- subset(myel, idents = c("Macrophage", "Monocyte"))
macro <- FindVariableFeatures(macro, selection.method = "vst")
# Regress technical covariates
macro <- ScaleData(
macro,
features = rownames(macro),
vars.to.regress = c("nFeature_RNA", "nCount_RNA", "percent_mito")
)
colnames(myel@meta.data)
rm(macro)
macro <- read_rds(file.path(DIR_LOCAL_CACHE, "milich_B_macro_seurat.rds"))
# Top10 by logFC (sorted)
top10_logfc <- clustmarks %>%
group_by(cluster) %>%
filter(avg_log2FC > 1) %>%
arrange(desc(avg_log2FC)) %>%
slice_head(n = 10) %>%
ungroup()
# -----------------------------------------------------------------------------
# 3) Markers + top10 signatures
# -----------------------------------------------------------------------------
clustmarks <- FindAllMarkers(macro, logfc.threshold = 0.25, min.pct = 0.3, only.pos = TRUE) %>%
filter(p_val_adj < 0.05)
# Top10 by logFC (sorted)
top10_logfc <- clustmarks %>%
group_by(cluster) %>%
filter(avg_log2FC > 1) %>%
arrange(desc(avg_log2FC)) %>%
slice_head(n = 10) %>%
ungroup()
write.csv(top10_logfc, file.path(DIR_TABLES, "top10_logfc_milich_macrophage_clusters.csv"), row.names = FALSE)
# -----------------------------------------------------------------------------
# 4) Cluster counts + proportions
# -----------------------------------------------------------------------------
cluster_counts <- table(Idents(macro))
cluster_props  <- prop.table(cluster_counts)
cluster_summary_milich <- tibble(
Cluster = names(cluster_counts),
Cell_Count = as.numeric(cluster_counts),
Proportion = as.numeric(cluster_props)
)
write_csv(cluster_summary_milich, file.path(DIR_TABLES, "cluster_summary_milich.csv"))
source("scripts/pipeline/00_config.R")
suppressPackageStartupMessages({
library(tidyverse)
library(Seurat)
})
dataset_id <- "brennan_C"
# -----------------------------------------------------------------------------
# 1) Load matrix and create Seurat object
# -----------------------------------------------------------------------------
mtx_dir <- file.path(DIR_LOCAL_DATA, "GSE196928", "data")
mtx_file      <- file.path(mtx_dir, "GSM5904827_B3_matrix.mtx.gz")
features_file <- file.path(mtx_dir, "GSM5904827_B3_features.tsv.gz")
barcodes_file <- file.path(mtx_dir, "GSM5904827_B3_barcodes.tsv.gz")
stopifnot(file.exists(mtx_file), file.exists(features_file), file.exists(barcodes_file))
mtx_file      <- file.path(mtx_dir, "GSM5904827_B3_matrix.mtx.gz")
stopifnot(file.exists(mtx_file), file.exists(features_file), file.exists(barcodes_file))
mtx_obj <- ReadMtx(mtx = mtx_file, features = features_file, cells = barcodes_file)
seu <- CreateSeuratObject(counts = mtx_obj, min.cells = 3, min.features = 200)
message("Loaded Brennan B3: ", nrow(seu), " genes x ", ncol(seu), " cells")
# -----------------------------------------------------------------------------
# 2) QC filtering (same as legacy)
# -----------------------------------------------------------------------------
seu[["percent.mt"]] <- PercentageFeatureSet(seu, pattern = "^mt-")
seu <- subset(
seu,
subset =
nFeature_RNA > 500 & nFeature_RNA < 7500 &
percent.mt < 20 &
nCount_RNA > 1500 & nCount_RNA < 50000
)
message("After QC: ", nrow(seu), " genes x ", ncol(seu), " cells")
# -----------------------------------------------------------------------------
# 3) Normalize + HVGs + scale + PCA
# -----------------------------------------------------------------------------
seu <- NormalizeData(seu)
seu <- FindVariableFeatures(seu, selection.method = "vst")
seu <- ScaleData(seu, features = rownames(seu))
seu <- RunPCA(seu, features = VariableFeatures(seu))
ElbowPlot(seu)
# -----------------------------------------------------------------------------
# 4) Clustering + embeddings (same legacy params)
# -----------------------------------------------------------------------------
dims_use <- 1:15
seu <- FindNeighbors(seu, dims = dims_use)
seu <- FindClusters(seu, resolution = 0.1)
# Compute embeddings for later figure script
set.seed(123)
seu <- RunTSNE(seu, dims = dims_use)
Idents(seu) <- "RNA_snn_res.0.1"
TSNEPlot(seu)
# -----------------------------------------------------------------------------
# 5) Cluster markers (all cells) — save per cluster
# -----------------------------------------------------------------------------
all_markers <- FindAllMarkers(seu, logfc.threshold = 0.25, min.pct = 0.3, only.pos = TRUE) %>%
filter(p_val_adj < 0.05)
dir.create(file.path(DIR_TABLES, "brennan_C"), showWarnings = FALSE, recursive = TRUE)
for (cl in sort(unique(all_markers$cluster))) {
tmp <- all_markers %>%
filter(cluster == cl) %>%
arrange(desc(avg_log2FC))
write.csv(tmp,
file.path(DIR_TABLES, "brennan_C", paste0("markers_allcells_cluster_", cl, ".csv")),
row.names = FALSE)
}
# -----------------------------------------------------------------------------
# 6) Coarse cell-type annotation
# -----------------------------------------------------------------------------
new_clusters <- c(
"Microglia", "Macrophages", "Monocytes", "Endothelial Cells",
"Intermediate Progenitors", "Ependymal cells", "Neutrophils",
"Oligodendrocytes", "Miscelaneous", "Astrocytes"
)
# This assumes cluster levels order matches the legacy run.
# If the number/order of clusters changes, update this mapping.
names(new_clusters) <- levels(seu)
seu <- RenameIdents(seu, new_clusters)
seu$celltype <- Idents(seu)
# Cache all-cells object locally
saveRDS(seu, file.path(DIR_LOCAL_CACHE, "brennan_C_allcells_seurat.rds"))
# -----------------------------------------------------------------------------
# 7) Subset macrophages + monocytes and recluster
# -----------------------------------------------------------------------------
macro <- subset(seu, ident = c("Macrophages", "Monocytes"))
macro <- NormalizeData(macro)
macro <- FindVariableFeatures(macro, selection.method = "vst")
macro <- ScaleData(
macro,
features = rownames(macro),
vars.to.regress = c("nFeature_RNA", "nCount_RNA")
)
macro <- RunPCA(macro, npcs = 50, features = VariableFeatures(macro))
ElbowPlot(macro, ndims = 50)
macro <- FindNeighbors(macro, dims = 1:30, reduction = "pca")
macro <- FindClusters(macro, resolution = 0.4)
# Compute embeddings for later figure script
set.seed(123)
macro <- RunTSNE(macro, dims = 1:30, verbose = TRUE)
TSNEPlot(macro)
# Cache macrophage+monocyte object locally
saveRDS(macro, file.path(DIR_LOCAL_CACHE, "brennan_C_macrophage_monocyte_seurat.rds"))
# Cache macrophage+monocyte object locally
saveRDS(macro, file.path(DIR_LOCAL_CACHE, "brennan_C_macro_seurat.rds"))
# -----------------------------------------------------------------------------
# 8) Macrophage cluster markers + top10 signatures (tables only)
# -----------------------------------------------------------------------------
clustmarks <- FindAllMarkers(macro, logfc.threshold = 0.25, min.pct = 0.3, only.pos = TRUE) %>%
filter(p_val_adj < 0.05)
# Top10 by adj p (with avg_log2FC > 1)
top10 <- clustmarks %>%
group_by(cluster) %>%
filter(avg_log2FC > 1) %>%
slice_head(n = 10) %>%
ungroup()
write.csv(top10, file.path(DIR_TABLES, "top10_brennan_macrophage_clusters.csv"), row.names = FALSE)
# Top10 by logFC — as legacy
top10_logfc <- clustmarks %>%
group_by(cluster) %>%
filter(avg_log2FC > 1) %>%
arrange(desc(avg_log2FC)) %>%
slice_head(n = 10) %>%
ungroup()
write.csv(top10_logfc, file.path(DIR_TABLES, "top10_logfc_brennan_macrophage_clusters.csv"), row.names = FALSE)
# -----------------------------------------------------------------------------
# 9) Cluster counts + proportions (macrophage+monocyte reclustering)
# -----------------------------------------------------------------------------
cluster_counts <- table(Idents(macro))
cluster_props  <- prop.table(cluster_counts)
cluster_summary_brennan <- tibble(
Cluster = names(cluster_counts),
Cell_Count = as.numeric(cluster_counts),
Proportion = as.numeric(cluster_props)
)
write_csv(cluster_summary_brennan, file.path(DIR_TABLES, "cluster_summary_brennan.csv"))
message("✅ Brennan dataset processing complete.")
source("scripts/pipeline/00_config.R")
suppressPackageStartupMessages({
library(SingleR)
library(Seurat)
library(tidyverse)
library(ggplot2)
library(patchwork)
})
# ---- Paths ----
out_dir <- file.path(DIR_TABLES, "singler")
dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
fig_out <- file.path(DIR_FIGS, "paper")
dir.create(fig_out, showWarnings = FALSE, recursive = TRUE)
# ---- Load cached Seurat objects (local-only) ----
path_A <- file.path(DIR_LOCAL_CACHE, "salvador_A_macrophages_seurat.rds")                 # reference A
path_B <- file.path(DIR_LOCAL_CACHE, "milich_B_macro_seurat.rds")     # query B / reference B
path_C <- file.path(DIR_LOCAL_CACHE, "brennan_C_macro_seurat.rds")         # query C
stopifnot(file.exists(path_A), file.exists(path_B), file.exists(path_C))
mac_A <- readRDS(path_A)
mac_B <- readRDS(path_B)
mac_C <- readRDS(path_C)
# Ensure identities are set (SingleR labels = cluster identities)
# If these are already set properly, this is harmless.
Idents(mac_A) <- Idents(mac_A)
Idents(mac_B) <- Idents(mac_B)
Idents(mac_C) <- Idents(mac_C)
# -----------------------------------------------------------------------------
# Helper: run SingleR + make contingency + long df
# -----------------------------------------------------------------------------
run_singler_pair <- function(ref_obj, test_obj, pair_id,
ref_name = "ref", test_name = "test",
de_method = "wilcox") {
ref_labels <- Idents(ref_obj)
test_clusters <- as.factor(Idents(test_obj))
# Run SingleR
sr <- SingleR(
test   = GetAssayData(test_obj, slot = "data"),
ref    = GetAssayData(ref_obj,  slot = "data"),
labels = ref_labels,
de.method = de_method
)
# Per-cell predicted reference labels
pred <- sr$labels
# Contingency table: test cluster vs predicted reference label
tab <- table(
query_clusters = test_clusters,
predicted_cell_types = pred
)
# Save contingency as CSV (wide)
tab_df <- as.data.frame.matrix(tab) %>%
rownames_to_column("query_cluster")
write_csv(tab_df, file.path(out_dir, paste0("contingency_", pair_id, ".csv")))
# Long format for plotting
df_long <- as.data.frame(tab) %>%
rename(value = Freq) %>%
mutate(
query_clusters = as.character(query_clusters),
predicted_cell_types = as.character(predicted_cell_types),
pair = pair_id,
ref = ref_name,
test = test_name
)
write_csv(df_long, file.path(out_dir, paste0("df_long_", pair_id, ".csv")))
# Optional: save per-cell label assignments (can be big; still usually manageable)
# If too large, comment these out.
labels_df <- tibble(
cell = colnames(test_obj),
query_cluster = as.character(test_clusters),
predicted_ref_cluster = pred
)
write_csv(labels_df, file.path(out_dir, paste0("singler_labels_", pair_id, ".csv")))
list(singleR = sr, tab = tab, df_long = df_long)
}
# -----------------------------------------------------------------------------
# Run A vs B, A vs C, B vs C
# -----------------------------------------------------------------------------
res_AxB <- run_singler_pair(ref_obj = mac_A, test_obj = mac_B, pair_id = "AxB",
ref_name = "A", test_name = "B", de_method = "wilcox")
# -----------------------------------------------------------------------------
# Helper: run SingleR + make contingency + long df
# -----------------------------------------------------------------------------
run_singler_pair <- function(ref_obj, test_obj, pair_id,
ref_name = "ref", test_name = "test",
de_method = "wilcox") {
ref_labels <- Idents(ref_obj)
test_clusters <- as.factor(Idents(test_obj))
# Run SingleR
sr <- SingleR(
test   = GetAssayData(test_obj, layer = "data"),
ref    = GetAssayData(ref_obj,  layer = "data"),
labels = ref_labels,
de.method = de_method
)
# Per-cell predicted reference labels
pred <- sr$labels
# Contingency table: test cluster vs predicted reference label
tab <- table(
query_clusters = test_clusters,
predicted_cell_types = pred
)
# Save contingency as CSV (wide)
tab_df <- as.data.frame.matrix(tab) %>%
rownames_to_column("query_cluster")
write_csv(tab_df, file.path(out_dir, paste0("contingency_", pair_id, ".csv")))
# Long format for plotting
df_long <- as.data.frame(tab) %>%
rename(value = Freq) %>%
mutate(
query_clusters = as.character(query_clusters),
predicted_cell_types = as.character(predicted_cell_types),
pair = pair_id,
ref = ref_name,
test = test_name
)
write_csv(df_long, file.path(out_dir, paste0("df_long_", pair_id, ".csv")))
# Optional: save per-cell label assignments (can be big; still usually manageable)
# If too large, comment these out.
labels_df <- tibble(
cell = colnames(test_obj),
query_cluster = as.character(test_clusters),
predicted_ref_cluster = pred
)
write_csv(labels_df, file.path(out_dir, paste0("singler_labels_", pair_id, ".csv")))
list(singleR = sr, tab = tab, df_long = df_long)
}
# -----------------------------------------------------------------------------
# Run A vs B, A vs C, B vs C
# -----------------------------------------------------------------------------
res_AxB <- run_singler_pair(ref_obj = mac_A, test_obj = mac_B, pair_id = "AxB",
ref_name = "A", test_name = "B", de_method = "wilcox")
# -----------------------------------------------------------------------------
# Helper: run SingleR + make contingency + long df
# -----------------------------------------------------------------------------
run_singler_pair <- function(ref_obj, test_obj, pair_id,
ref_name = "ref", test_name = "test",
de_method = "wilcox") {
ref_labels <- Idents(ref_obj)
test_clusters <- as.factor(Idents(test_obj))
# Run SingleR
sr <- SingleR(
test   = GetAssayData(test_obj, layer = "data"),
ref    = GetAssayData(ref_obj,  layer = "data"),
labels = ref_labels,
de.method = de_method
)
# Per-cell predicted reference labels
pred <- sr$labels
# Contingency table: test cluster vs predicted reference label
tab <- table(
query_clusters = test_clusters,
predicted_cell_types = pred
)
# Save contingency as CSV (wide)
tab_df <- as.data.frame.matrix(tab) %>%
rownames_to_column("query_cluster")
write_csv(tab_df, file.path(out_dir, paste0("contingency_", pair_id, ".csv")))
# Long format for plotting
df_long <- as.data.frame(tab)
# Robustly rename the count column to "value"
# (it is usually "Freq", but not always)
count_col <- setdiff(names(df_long), c("query_clusters", "predicted_cell_types"))[1]
names(df_long)[names(df_long) == count_col] <- "value"
df_long <- df_long %>%
mutate(
query_clusters = as.character(query_clusters),
predicted_cell_types = as.character(predicted_cell_types),
value = as.numeric(value),
pair = pair_id,
ref = ref_name,
test = test_name
)
write_csv(df_long, file.path(out_dir, paste0("df_long_", pair_id, ".csv")))
# Optional: save per-cell label assignments (can be big; still usually manageable)
# If too large, comment these out.
labels_df <- tibble(
cell = colnames(test_obj),
query_cluster = as.character(test_clusters),
predicted_ref_cluster = pred
)
write_csv(labels_df, file.path(out_dir, paste0("singler_labels_", pair_id, ".csv")))
list(singleR = sr, tab = tab, df_long = df_long)
}
# -----------------------------------------------------------------------------
# Run A vs B, A vs C, B vs C
# -----------------------------------------------------------------------------
res_AxB <- run_singler_pair(ref_obj = mac_A, test_obj = mac_B, pair_id = "AxB",
ref_name = "A", test_name = "B", de_method = "wilcox")
res_AxC <- run_singler_pair(ref_obj = mac_A, test_obj = mac_C, pair_id = "AxC",
ref_name = "A", test_name = "C", de_method = "wilcox")
res_BxC <- run_singler_pair(ref_obj = mac_B, test_obj = mac_C, pair_id = "BxC",
ref_name = "B", test_name = "C", de_method = "wilcox")
# -----------------------------------------------------------------------------
# Plot heatmaps with shared fill scale
# -----------------------------------------------------------------------------
df_long_AxB <- res_AxB$df_long
df_long_AxC <- res_AxC$df_long
df_long_BxC <- res_BxC$df_long
common_limits <- range(c(df_long_AxB$value, df_long_AxC$value, df_long_BxC$value))
fill_scale <- scale_fill_gradient(low = "white", high = "#A1C9F4", limits = common_limits)
make_heatmap <- function(df_long, title, xlab, ylab) {
ggplot(df_long, aes(x = predicted_cell_types, y = query_clusters, fill = value)) +
geom_tile(color = "white") +
fill_scale +
labs(
title = title,
x = xlab,
y = ylab,
fill = "Number of cells\npredicted on\nreference clusters"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 18),
axis.text.x = element_text(size = 13, angle = 45, hjust = 1),
axis.text.y = element_text(size = 13),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
legend.text = element_text(size = 12),
legend.title = element_text(size = 12),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
}
p1 <- make_heatmap(df_long_AxB, "Dataset A\nvs Dataset B", xlab = "Dataset A", ylab = "Dataset B")
p2 <- make_heatmap(df_long_AxC, "Dataset A\nvs Dataset C", xlab = "Dataset A", ylab = "Dataset C")
p3 <- make_heatmap(df_long_BxC, "Dataset B\nvs Dataset C", xlab = "Dataset B", ylab = "Dataset C")
p1
final_plot <- p1 + p2 + p3 + plot_layout(ncol = 3, guides = "collect")
final_plot
fill_scale <- scale_fill_gradient(low = "white", high = "#F4A3C0", limits = common_limits)
make_heatmap <- function(df_long, title, xlab, ylab) {
ggplot(df_long, aes(x = predicted_cell_types, y = query_clusters, fill = value)) +
geom_tile(color = "white") +
fill_scale +
labs(
title = title,
x = xlab,
y = ylab,
fill = "Number of cells\npredicted on\nreference clusters"
) +
theme_minimal() +
theme(
plot.title = element_text(size = 18),
axis.text.x = element_text(size = 13, angle = 45, hjust = 1),
axis.text.y = element_text(size = 13),
axis.title.x = element_text(size = 16),
axis.title.y = element_text(size = 16),
legend.text = element_text(size = 12),
legend.title = element_text(size = 12),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
}
p1 <- make_heatmap(df_long_AxB, "Dataset A\nvs Dataset B", xlab = "Dataset A", ylab = "Dataset B")
p2 <- make_heatmap(df_long_AxC, "Dataset A\nvs Dataset C", xlab = "Dataset A", ylab = "Dataset C")
p3 <- make_heatmap(df_long_BxC, "Dataset B\nvs Dataset C", xlab = "Dataset B", ylab = "Dataset C")
final_plot <- p1 + p2 + p3 + plot_layout(ncol = 3, guides = "collect")
final_plot
ggsave(
filename = file.path(fig_out, "singler_heatmaps.png"),
plot = final_plot,
width = 18,
height = 6,
dpi = 300,
bg = "white"
)
message("✅ SingleR cross-dataset matching complete.")
